<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            padding:16px;
        }
        h1, h2 {
            color: rgb(8, 101, 101);
        }
        ul li a {
            font-size: 1.2rem;
            text-decoration: none;
            color: azure;
            background-color: darkblue;
            padding:4px;
            border-radius: 8px;;
        }
        ul li {
            color: darkblue;
            padding:8px;
        }
    </style>
</head>
<body>
    <h1>Turinys</h1>
    <ul>
        <li>
            <a href="#NDexpress">Node Express sukūrimo instrukcija</a> 
        </li>
        <li>
            <a href="#react-express">Duomenų bazės sujungimo su React ir Node Express instrukcija</a>
        </li>
        <li>
            <a href="#irasu-pavaizdavimas">Duomenų bazės įrašų pavaizdavimas</a>
        </li>
        <li>
            <a href="#irasu-ivedimas">Įrašų įvedimo iš React į duomenų bazę instrukcija</a>
        </li>
        <li>
            <a href="#irasu-trynimas">Įrašų trynimo instrukcija</a>
        </li>
            
            
            <a href="#NDexpress"></a>
       
    </ul>
    <h2 id="NDexpress">Node Express sukūrimo instrukcija</h2>
    <ol>
        <li>Reikia instaliuoti node (npm init, npm install), nodemon, mysql, cors<br>
            const express = require('express')<br>
            const mysql = require('mysql')<br>
            const cors = require('cors')
        </li>
        <li>Nurodoma naudoti express moduli ir portą:<br>
            const app = express()<br>
            const port = 3006<br>
        </li>
        <li>app.get grąžina turinį į užklausas, šiuo atveju į blank:<br>
            app.get('/', (req, res) => {<br>
              res.send('Hello World!')<br>
            })
        </li>
        <li>Įvedamas veikimo patikrinimas:<br>
            app.listen(port, () => { <br>
            console.log(`Example app listening at http://localhost:${port}`)<br>
            })
        </li>
        <li>Įvedami nustatymai sąsajai su duomenų baze (DB serveris tur būti paleistas)
            const sasaja = mysql.createConnection({ <br>
                host: "localhost",<br>
                user: "root",<br>
                database: "prekiu_krepselis",<br>
                password: "root" <br>
              });
        </li>
        <li>Sukuriama sąsaja su DB:<br>
            sasaja.connect(function(err) {<br>
                if (err) throw err;<br>
                console.log("Connected!");<br>
              });
        </li>
        <li> Aktyvuojamas cors:<br>
            app.use(cors());
        </li>
        <li>Ši komanda įgalina atpažinti siunčiamą infprmaciją kaip tekstą ar masyvą:<br>
            app.use(express.urlencoded({<br>
                extended: true<br>
                }))
        </li>
        <li>Nurodo automatiškai perskaityti JSON informaciją:<br>
            app.use(express.json());
        </li>
        <li>Patikrina JSON perskaitymo veikimą:<br>
            app.get('/JSONtest', (req, res) => { <br>
                res.send(JSON.stringify({JSONtest: 'Viskas OK'}))<br>
              })
        </li>
        <li>Prisijungimas prie konkrečios DB lentelės:<br>
            app.get('/prekes', (req, res) => {<br>
                const sqlUzklausa = `select * from prekes`<br>
                sasaja.query(sqlUzklausa, (err, results) =>{<br>
                if (err) {console.log("Klaida");throw err}<br>
                else {res.send(results)} <br>
                }) })
        </li>
    </ol>
    <h2 id="react-express">Duomenų bazės sujungimo su React ir Node Express instrukcija</h2>
    <ol>
        <li>Susikuriama duomenų bazė</li>
        <li>Susikuriamas React App.jsx</li>
        <li>Įdiegiama Axios biblioteka (galima naudoti JS Fetch API su JS)<br>su 'npm install axios'.<br>Įterpiamas į App.jsx su 'import axios from "axios"'.<br>Axios reikalingas React susijungimui su Express serveriu.</li>
        <li>Pasileidžiamas React serveris, po to pasleidžiamas Express serveris su Nodemon<br> Turi rodyti 'connected!'
        </li>
        <li>serverio .js byloje padaromas testinis JSON perdavimas:<br>' res.send(JSON.stringify({JSONtest: 'Viskas OK'}))'<br>Rezultatas patikrinamas su naršykle.<br>Dabar reikia, kad į šį perdavimą (aka routerį) kreiptųsi React</li>
        <li>useEffect naudojamas šiam kreipimuisi. Įvedamas į App.jsx funkcijos kūną.<br>
        Pirmas jo argumentas - funkcija, antras - tuščias masyvas, kuris rodo, kad useEffect bus aktyvuota vieną kartą.<br>
        Su axios krepiamasi į kitą serverį ir į konkretų puslapį.<br>
        Grąžinamas res.data yra tik duomenys, nes tik jų reikia.<br>
        useEffect( () => {<br>
            axios.get('http://localhost:3003/JSONtest')<br>
            .then (res => {<br>
                console.log(res.data)<br>
            })}, []) </li>
        <li>Po to reikalingi du 'powershell' terminalai.<br>
        Iš vieno pasileidžiamas React, iš kito - Express serveriai.</li>
        <li>Toliau sukuriame užklausą e-server.js byloje į duomenų bazės lentelę 'prekes' je naršyklės užklausoje yra '/prekes' kelias:<br>
        app.get('/prekes', (req, res) => {<br>
            const sqlUzklausa = `select * from zveris`</b>
            sasaja.query(sqlUzklausa, (err, results) =>{<br>
            if (err) {console.log("Klaida");throw err}<br>
            else {res.send(results)}  }) })<br>
            Čia 'sqlUzklausa' yra kreipimosi turinys, o 'sasaja.query' ją persiunčia, 'res.send' grąžina rezultatą naršyklei.<br>
            Papildomai pasitikrinti 'sasaja' aprašyme, ar nurodyta duomenų bazė ('prekiu_krepselis' šiuo atveju).</li>
        <li>Po to atitinkamai pakeičiamas kelias React serveryje:<br>axios.get('http://localhost:3003/prekes')</li>
        <li>Naršyklės 'Network' kortelėje galima matyti sąsajos procesus.</li>  
    </ol>
    <h2 id="irasu-pavaizdavimas">Duomenų bazės įrašų pavaizdavimas</h2>
    <ol>
        <li>React'o App.jsx byloje importuojamas useState hukas:<br>
            import {useEffect, useState} from "react"<br>
            Jį galima buvo importuoti iš pat pradžių.
        </li>
        <li>Po to useState hukas panaudojamas su paimamo masyvo duomenimis ten pat(App.jsx):<br>
            const [prekes, setPrekes] = useState ([])<br>
            Čia useState argumente nurodoma pradinė steito 'prekes' būsena, šiuo aveju tuščias masyvas.
        </li>
        <li>Po to useEffect huko viduje po .then usePrekes prisikiriamas masyvo duomenys iš Express serverio (ir DB tuo pačiu):<br>
            .then (res => {<br>
            setPrekes = res.data})<br>
            Taip pakeičiamas steitas iš tuščio masyvo į masyvą iš Express serverio atsakymo į užklausą.
        </li>
        <li>Susikuriami komponentai, kuriuose formuojamas JSX vaizdas 'return' skiltyje:<br>
            export default function Table () {<br>
            return (<div></div>) }
        </li>
        <li>React App.jsx byloje importuojamas tėvinis pavaizdavimo komponentas:<br>
            import component from "./Components/component"
        </li>
        <li>Vaikinis komponentas gali būti padauginamas tėviname komponente imant duomenis iš Express/DB ir naudojant .map metodą.<br> Vaikinis komponentas importuojamas tėv. komponente.:<br>
            import Vaikkomp from "./Components/VaikKomp"<br>
        </li>
        <li>Susikuriamos atitinkamų komponentų CSS bylos ir pasitikrinamas bendras vaizdas dar be kintamųjų.
        </li>
        <li>Tuomet grįžtam į App.jsx ir useState huko pirmasis kintamasis 'prekes' pažymimas JSX kodo return sekcijoje esantis propsu tėviniam komponentui.<br>
            div prekes={prekes}>div
        </li>
        <li>Tėvinio komponento funkcijos argumente Express/DB duomenų kintamasis nurodomas kaip savybė (aka propsas):<br>
            function Table ( {prekes} )
        </li>
        <li>Po to formuojamas tėv. komponentas JSX'as su .map kiekvienam elementui 'item' išvedant vaikinį komponentą, kuriame nnustatomas jo propsas - masyvo elementas:<br>
            {prekes.map( item => <TableRow key = {item.ID} item={item}></TableRow>) }<br>
            key savybė turi imti unikalią identifikacinę savybę (šiuo atveju ID), kad galėtų atskirti vienarūšius komponentus tarpusavyje
        </li>Po to vaikinio komponento propsas (item) įkeliamas į jo funkcijos argumentą:<br>
            function TableRow ( {item} )
        <li>Po to propso elementai sukeliami į jų vietas JSX'e:<br>
            div{item.kaina}div
        </li>
    </ol>
    <h2 id="irasu-ivedimas">Įrašų įvedimo iš React į duomenų bazę instrukcija</h2>
    <ol>
        <li>Sukuriamas įvedimo komponentas (jei reikia) ir jo CSS'as, importuojamas į App.jsx.
        </li>
        <li>Kiekvienai įvesties vertei sukuriamas steitas (šiuo atveju, jų objektas) komponento jsx byloje:<br>
            const [prekes, setPrekes] = useState( {<br>
                pavadinimas: "";<br>
            } )<br>
            Propso funkcijai nereikia, nes čia sukuriamas tuščias objektas, kuris užpildomas iš input'ų ir po to duomenys siunčiami į Express/DB.
        </li>
        <li>Po to ten pat sukuriama kontrolės funkcija:<br>
            const formControl = (e, what) => {<br>
                const vertesCopy = {...vertes};<br>
                vertesCopy[what] = e.target.value;<br>
                setVertes (vertesCopy);}
        </li>  
        <li>Toliau sukuriamas pačios formos HTML'as:<br>
            label for="pavadinimas">Pavadinimas</label><br>
            input type="text" value={prekes["pavadinimas"]} onChange={(e) => formControl(e, "pavadinimas")}/><br>
            Pabaigoje įdedamas mygtukas.
        </li> 
        <li>App.jsx byloje susikuriama funkcija, kuri pasiųs naujus duomenis į duomenų bazės lentelę.<br>
            const sukurti = prekes => {<br>
                axios.post('http://localhost:3003/prekes', e)<br>
                .then (res => {<br>
                    setAtnaujinti(Date.now());<br>
                    console.log(res.data) }) }
        </li>
        <li>^i funkcija nurodoma kaip įvedimo komponento propsas App.jsx byloje:<br>
            Menu sukurti={sukurti}></Menu><br>
            Ir tas propsas nurodomas įvedimo komponento funkcijos argumente:<br>
            function Menu ( {sukurti} )
        </li>
        <li>Po to einama į Express .js bylą ir parašomas išsiuntimas:<br>
            app.post('/prekes', (req, res) => {<br>
                const sqlParaiska = `insert into prekes<br>
                (pavadinimas, prekeskodas, kaina, paskuzsakymas, kiekis)<br>
                values (?, ?, ?, ?, ?)`<br>
                sasaja.query(sqlParaiska, [ <br>
                  req.body[pavadinimas],<br>
                  req.body[prekeskodas],<br>
                  req.body[kaina],<br>
                  req.body[paskuzsakymas],<br>
                  req.body[kiekis]<br>
                ], (err, results) => {<br>
                if (err) {console.log("Klaida");throw err}<br>
                else {res.send(results)} <br>
                })})
        </li>
        <li>Po to įvedimo komponento mygtuke onClick atveju įvedama nauja funkcija:<br>
            <button className="accordion" onClick= {handleSukurti}>Patvirtinkite</button>
        </li>
        <li>Ši funkcija nurodoma ten pat prieš return sekciją, kad onClick atveju iššauktų funkciją 'sukurti', kurios argumentu nurodytas įvestų duomenų objektas:<br>
            const handleSukurti = () => {<br>
                sukurti(prekes) }
        </li>
        <li>Po to reikalinga, kad duomenų atnaujinimas būtų automatiškai pavaizduojamas (be reload) JSX'se. Tam sukuriamas steitas, kuris seka laiko pasikeitimus realiu laiku App.jsx byloje:<br>
            const [laikas, setLaikas] = useState (Date(now))<br>
            Po to realaus laiko nustatymas užfiksuojamas funkcijoje 'sukurti', kai jinai yra iššaukiama ('post', nusiunčiami duomenys):<br>
            const sukurti = prekes => {<br>
                axios.post('http://localhost:3006/prekes', prekes)<br>
                .then (res => {<br>
                setAtnaujinti(Date.now());}<br>
            Ir steitas nurodomas 'get' funkcijos antrajame argumente. Pasikeitus argumentui, 'get' iššaukiamas parsisiųsti duomenis iš DB.<br>
            useEffect( () => {<br>
                axios.get('http://localhost:3006/prekes')<br>
                .then (res => {<br>
                    setPrekes(res.data)<br>
                })}, [laikas])
        </li>
        <li>Norint grąžinti įvedimo formos pradinę būseną (be suvedimo duomenų), paimami pradinės būsenos nustatymai ir įterpiami po 'sukurti' komandos iššaukimo komponente:<br>
            const handleSukurti = () => {<br>
                sukurti(prekes)<br>
                setPrekes ({<br>
                    pavadinimas: "",<br>
                })<br>
            }
        </li>
    </ol>
    <h2 id="irasu-trynimas">Įrašų trynimo instrukcija</h2>
    <ol>
        <li></li>
    </ol>
</body>
</html>